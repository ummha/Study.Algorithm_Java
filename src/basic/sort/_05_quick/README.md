[:file_folder: **Algorithm List**](https://github.com/dlalstj0213/Study.Algorithm_Java)

[:arrow_backward: **BACK**](../)

---

# 정렬 ( Sort )

![선택정렬](../../../../imgs/quick_sort_animation.gif)

> [이미지 출처 : Quick Sort Animation *.wikipedia*]

## 개념
### 요약

- ‘찰스 앤터니 리처드 호어(Charles Antony Richard Hoare)’가 개발한 정렬 알고리즘
- 퀵 정렬은 **불안정 정렬** 에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 **비교 정렬** 에 속한다.
- 분할 정복 알고리즘의 하나로, 평균적으로 **매우 빠른 수행 속도**를 자랑하는 정렬 방법
  - 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 **비균등하게** 분할한다.
- 분할 정복(divide and conquer) 방법
  - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
  - 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
- **과정 설명**
  1. 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
  2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)
  3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
     - 분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
     - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
  4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
     - 리스트의 크기가 0이나 1이 될 때까지 반복한다.


### 자세히

- 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
- 퀵 정렬은 다음의 단계들로 이루어진다.
  - **분할(Divide)**: 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
  - **정복(Conquer)**: 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 **순환 호출**을 이용하여 다시 분할 정복 방법을 적용한다.
  - **결합(Combine)**: 정렬된 부분 배열들을 하나의 배열에 합병한다.
  - 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

![선택정렬이미지](../../../../imgs/quick_sort.png)

> [이미지 출처 : [gmlwjd9405.github.io](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)]

### 퀵 정렬 성능 향상 방법

- 작은 데이터 구간에는 **삽입 정렬**을 사용하여 퀵 정렬의 재귀의 깊이를 줄여 스택 사용을 줄여 준다
- **비 재귀** 구현
- **난수**(Random) 분할 > Worst 경우 인 정렬된 배열과 역순 배열일 때 문제를 해결하기 위해 난수로 선택한다
- 메디안 퀵 정렬(Median of Three QuickSort) - **세 값**(처음, 가운데, 끝)의 **중윗값**을 찾아 **Pivot으로 선택**한다

## 특징

### 장점

- 속도가 빠르다.
  - 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
- 추가 메모리 공간을 필요로 하지 않는다.
  - 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.

### 단점

- 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

## References
- https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html
- https://www.daleseo.com/sort-quick/
- https://javaoop.tistory.com/8

---

[:arrow_up_small: **Top**](#)